<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice-Controlled Periodontal Chart - Clinical Tables</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .voice-controls {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .voice-button {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .voice-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.3);
        }

        .voice-button.recording {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            animation: blink 1s infinite;
        }

        .status-indicator.connected {
            background: #27ae60;
            animation: none;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .instructions {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 10px;
            padding: 20px;
            margin: 20px;
        }

        .instructions h3 {
            color: #0c5460;
            margin-bottom: 15px;
        }

        .instructions ul {
            color: #0c5460;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .clear-button {
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .clear-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(230, 126, 34, 0.3);
        }

        .test-buttons {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .test-button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .test-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3);
        }

        /* Clinical Table Styles */
        .chart-container {
            padding: 20px;
            overflow-x: auto;
        }

        .clinical-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
            font-size: 12px;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .clinical-table th,
        .clinical-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
            vertical-align: middle;
            min-width: 35px;
            position: relative;
        }

        .clinical-table th {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            font-weight: bold;
            font-size: 11px;
        }

        .clinical-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .clinical-table tr:hover {
            background-color: #e3f2fd;
        }

        /* Row type styling */
        .row-label {
            background: linear-gradient(135deg, #3498db, #2980b9) !important;
            color: white !important;
            font-weight: bold;
            font-size: 11px;
            min-width: 80px;
            text-align: left;
            padding-left: 12px;
        }

        .tooth-number-row {
            background: linear-gradient(135deg, #e67e22, #d35400) !important;
            color: white !important;
            font-weight: bold;
            font-size: 13px;
        }

        .surface-row {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d) !important;
            color: white !important;
            font-size: 10px;
            font-weight: bold;
        }

        /* Data input cells */
        .data-cell {
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .data-cell:hover {
            background: #e3f2fd !important;
            border-color: #2196f3 !important;
        }

        .data-cell.updated {
            background: linear-gradient(135deg, #c8e6c9, #a5d6a7) !important;
            border-color: #4caf50 !important;
            animation: highlight 1s ease;
        }

        .data-cell.bleeding {
            background: linear-gradient(135deg, #ffcdd2, #ef9a9a) !important;
            color: #d32f2f;
            font-weight: bold;
        }

        .data-cell.high-probing {
            background: linear-gradient(135deg, #ffecb3, #fff176) !important;
            color: #f57f17;
            font-weight: bold;
        }

        .data-cell.critical-probing {
            background: linear-gradient(135deg, #ffcdd2, #ef9a9a) !important;
            color: #d32f2f;
            font-weight: bold;
        }

        .data-cell.missing-tooth {
            background: linear-gradient(135deg, #757575, #424242) !important;
            color: white !important;
            font-weight: bold;
        }
		
		.data-cell.high-cal {
			background: linear-gradient(135deg, #fff3e0, #ffcc02) !important;
			color: #e65100;
			font-weight: bold;
		}

		.data-cell.critical-cal {
			background: linear-gradient(135deg, #ffebee, #f44336) !important;
			color: white;
			font-weight: bold;
		}

		.instant-indicator {
			position: absolute;
			top: 20px;
			right: 20px;
			background: linear-gradient(135deg, #e74c3c, #c0392b);
			color: white;
			padding: 10px 20px;
			border-radius: 25px;
			font-weight: bold;
			font-size: 0.9em;
			opacity: 0;
			transform: scale(0.8);
			transition: all 0.3s ease;
		}

		.instant-indicator.active {
			opacity: 1;
			transform: scale(1);
			background: linear-gradient(135deg, #27ae60, #2ecc71);
			animation: instantPulse 0.5s ease;
		}

		@keyframes instantPulse {
			0% { transform: scale(1); }
			50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(39, 174, 96, 0.6); }
			100% { transform: scale(1); }
		}

		/* НОВОЕ: Стиль для частичных команд */
		.partial-command-indicator {
			background: linear-gradient(135deg, #f39c12, #e67e22);
			border-left: 4px solid #f39c12;
		}

		.partial-command-indicator::before {
			content: "⏳ ";
		}

        @keyframes highlight {
            0% { 
                background: linear-gradient(135deg, #ffeb3b, #ffc107) !important;
                transform: scale(1.1);
            }
            100% { 
                background: linear-gradient(135deg, #c8e6c9, #a5d6a7) !important;
                transform: scale(1);
            }
        }

        /* Responsive design */
        @media screen and (max-width: 1200px) {
            .clinical-table {
                font-size: 10px;
            }
            .clinical-table th,
            .clinical-table td {
                padding: 4px;
                min-width: 25px;
            }
        }

        @media screen and (max-width: 768px) {
            .clinical-table {
                font-size: 8px;
            }
            .clinical-table th,
            .clinical-table td {
                padding: 2px;
                min-width: 20px;
            }
        }

        .voice-feedback {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 350px;
            z-index: 1000;
        }

        .feedback-item {
            background: white;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateX(400px);
            animation: slideIn 0.5s ease forwards;
        }

        .feedback-item.success {
            border-left-color: #27ae60;
        }

        .feedback-item.error {
            border-left-color: #e74c3c;
        }

        .feedback-item.processing {
            border-left-color: #f39c12;
        }

        @keyframes slideIn {
            to { transform: translateX(0); }
        }

        @keyframes slideOut {
            to { transform: translateX(400px); opacity: 0; }
        }

        .feedback-text {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .feedback-details {
            font-size: 0.9em;
            color: #666;
        }

        .stats-panel {
            background: #f8f9fa;
            padding: 20px;
            border-top: 1px solid #e9ecef;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
        }

        /* Enhanced Visual Improvements */
        .quadrant-title {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            color: white;
            font-weight: bold;
            font-size: 16px;
            padding: 20px;
            text-align: center;
            margin: 25px 0 15px 0;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(142, 68, 173, 0.3);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .quadrant-title::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
			<h1>🦷 Voice-Controlled Periodontal Chart - Clinical Tables</h1>
			<p>Professional periodontal charting with voice recognition</p>
			<div id="instantIndicator" class="instant-indicator">
				⚡ INSTANT EXECUTION
			</div>
		</div>

        <div class="voice-controls">
            <button id="voiceButton" class="voice-button">🎤 Start Voice Input</button>
            <div class="connection-status">
                <div id="statusIndicator" class="status-indicator"></div>
                <span id="statusText">Disconnected</span>
            </div>
            <button id="clearButton" class="clear-button">🗑️ Clear All Data</button>
            <button id="debugButton" class="test-button" onclick="window.clinicalChart.debugConnection()">🔍 Debug Connection</button>
        </div>

        <div class="instructions">
            <h3>📋 Updated Voice Commands Examples:</h3>
            <ul>
                <li><strong>"Probing depth on tooth number 14 buccal surface 3 2 4"</strong> - Sets probing depths for buccal surface</li>
                <li><strong>"Probing depth on tooth number 14 lingual surface 2 3 3"</strong> - Sets probing depths for lingual surface</li>
                <li><strong>"Bleeding on probing tooth 12 buccal distal"</strong> - Marks bleeding on buccal distal</li>
                <li><strong>"Bleeding on probing tooth 12 lingual distal"</strong> - Marks bleeding on lingual distal</li>
                <li><strong>"Suppuration present on tooth 8 buccal distal"</strong> - Marks suppuration</li>
                <li><strong>"Suppuration present on tooth 8 lingual distal"</strong> - Marks suppuration</li>
                <li><strong>"Tooth 8 has mobility grade 2"</strong> - Sets mobility grade</li>
                <li><strong>"Furcation class 2 on tooth 6"</strong> - Sets furcation involvement</li>
                <li><strong>"Gingival margin on tooth 14 minus 1 0 plus 1"</strong> - Sets gingival margin</li>
                <li><strong>"Missing teeth 1 16 17 32"</strong> - Marks teeth as missing</li>
            </ul>
            
            <div class="test-buttons">
                <h4>🧪 Test Commands (Click to simulate):</h4>
                <button class="test-button" onclick="testCommand('probing depth on tooth number 14 buccal surface 3 2 4')">Test Buccal PD</button>
                <button class="test-button" onclick="testCommand('probing depth on tooth number 14 lingual surface 2 3 3')">Test Lingual PD</button>
                <button class="test-button" onclick="testCommand('bleeding on probing tooth 12 buccal distal')">Test BOP Buccal</button>
                <button class="test-button" onclick="testCommand('bleeding on probing tooth 12 lingual distal')">Test BOP Lingual</button>
                <button class="test-button" onclick="testCommand('suppuration present on tooth 8 buccal distal')">Test Suppuration</button>
                <button class="test-button" onclick="testCommand('tooth 8 has mobility grade 2')">Test Mobility</button>
                <button class="test-button" onclick="testCommand('furcation class 2 on tooth 6')">Test Furcation</button>
                <button class="test-button" onclick="testCommand('gingival margin on tooth 14 minus 1 0 plus 1')">Test GM</button>
                <button class="test-button" onclick="testCommand('missing teeth 1 16 17 32')">Test Missing</button>
				<button class="test-button" onclick="testCALCalculation()">🧮 Test CAL Auto-Calc</button>
            </div>
        </div>

        <div class="chart-container">
            <div class="quadrant-title">Upper Jaw (Teeth 1-16)</div>
            <table class="clinical-table" id="upperTable"></table>
            
            <div class="quadrant-title">Lower Jaw (Teeth 17-32)</div>
            <table class="clinical-table" id="lowerTable"></table>
        </div>

        <div class="stats-panel">
            <div class="stat-card">
                <div class="stat-value" id="commandsCount">0</div>
                <div class="stat-label">Voice Commands</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="teethUpdated">0</div>
                <div class="stat-label">Teeth Updated</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgProbing">-</div>
                <div class="stat-label">Avg Probing Depth</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="bleedingCount">0</div>
                <div class="stat-label">Bleeding Sites</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="missingCount">0</div>
                <div class="stat-label">Missing Teeth</div>
            </div>
			<div class="stat-card">
			<div class="stat-value" id="instantCommands">0</div>
			<div class="stat-label">⚡ Instant Commands</div>
			</div>
			<div class="stat-card">
			<div class="stat-value" id="partialCommands">0</div>
			<div class="stat-label">⏳ Partial Commands</div>
			</div>
        </div>
    </div>

    <div class="voice-feedback" id="voiceFeedback">
        <!-- Feedback items will appear here -->
    </div>

    <script>
        class ClinicalPeriodontalChart {
            constructor() {
                this.websocket = null;
                this.isConnected = false;
                this.isRecording = false;
                this.teethData = {};
                this.lastMessageTime = null;
                this.stats = {
                    commandsCount: 0,
                    teethUpdated: 0,
                    bleedingCount: 0,
                    missingCount: 0,
					instantCommands: 0,  // НОВОЕ
					partialCommands: 0   // НОВОЕ
                };
                
                this.serverUri = "ws://184.73.11.23:8766";
                
                this.initializeTeethData();
                this.createClinicalTables();
                this.setupEventListeners();
                this.connectToServer();
            }

            initializeTeethData() {
                // Initialize data structure for all 32 teeth
                for (let i = 1; i <= 32; i++) {
                    this.teethData[i] = {
                        probingDepthBuccal: ['', '', ''], // Distal, Mid, Mesial (Buccal)
                        probingDepthLingual: ['', '', ''], // Distal, Mid, Mesial (Lingual)
                        gingivaMarginBuccal: ['', '', ''], // Distal, Mid, Mesial (Buccal)
                        gingivaMarginLingual: ['', '', ''], // Distal, Mid, Mesial (Lingual)
                        clinicalAttachmentBuccal: ['', '', ''], // Distal, Mid, Mesial (Buccal)
                        clinicalAttachmentLingual: ['', '', ''], // Distal, Mid, Mesial (Lingual)
                        furcation: '',
                        suppressionBuccal: [false, false, false], // Distal, Mid, Mesial (Buccal)
                        suppressionLingual: [false, false, false], // Distal, Mid, Mesial (Lingual)
                        bleedingBuccal: [false, false, false], // Distal, Mid, Mesial (Buccal)
                        bleedingLingual: [false, false, false], // Distal, Mid, Mesial (Lingual)
                        mobility: '',
                        missing: false,
                        notes: ''
                    };
                }
            }

            createClinicalTables() {
                // Upper jaw data structure (teeth 1-16)
                const upperJawData = [
                    ["", "Buccal", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Facial", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Buccal", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Surface", "D", "B", "M", "D", "B", "M", "D", "B", "M", "D", "B", "M", "D", "B", "M", "D", "F", "M", "D", "F", "M", "D", "F", "M", "M", "F", "D", "M", "F", "D", "M", "F", "D", "M", "B", "D", "M", "B", "D", "M", "B", "D", "M", "B", "D", "M", "B", "D"],
                    ["PD", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["GM", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["CAL", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Furc", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Sup", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["BOP", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Mob", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Tooth", "1", "", "", "2", "", "", "3", "", "", "4", "", "", "5", "", "", "6", "", "", "7", "", "", "8", "", "", "9", "", "", "10", "", "", "11", "", "", "12", "", "", "13", "", "", "14", "", "", "15", "", "", "16"],
                    ["Surface", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D"],
                    ["PD", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["GM", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["CAL", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Sup", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Furc", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["BOP", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Mob", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
                ];

                // Lower jaw data structure (teeth 17-32)
                const lowerJawData = [
                    ["", "Buccal", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Facial", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Buccal", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Surface", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "D", "L", "M", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D", "M", "L", "D"],
                    ["PD", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["GM", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["CAL", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Sup", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Furc", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["BOP", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Mob", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Tooth", "32", "", "", "31", "", "", "30", "", "", "29", "", "", "28", "", "", "27", "", "", "26", "", "", "25", "", "", "24", "", "", "23", "", "", "22", "", "", "21", "", "", "20", "", "", "19", "", "", "18", "", "", "17"],
                    ["Surface", "D", "B", "M", "D", "B", "M", "D", "B", "M", "D", "B", "M", "D", "B", "M", "D", "F", "M", "D", "F", "M", "D", "F", "M", "M", "F", "D", "M", "F", "D", "M", "F", "D", "M", "B", "D", "M", "B", "D", "M", "B", "D", "M", "B", "D", "M", "B", "D"],
                    ["PD", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["GM", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["CAL", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Furc", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Sup", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["BOP", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
                    ["Mob", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
                ];

                this.createTable('upperTable', upperJawData, 'upper');
                this.createTable('lowerTable', lowerJawData, 'lower');
            }

            createTable(tableId, data, tableType) {
                const table = document.getElementById(tableId);
                table.innerHTML = '';
                
                data.forEach((row, rowIndex) => {
                    const tr = document.createElement('tr');
                    
                    row.forEach((cell, colIndex) => {
                        const td = document.createElement('td');
                        
                        if (colIndex === 0 && cell) {
                            td.className = 'row-label';
                            td.textContent = cell;
                        } else if (rowIndex === 0) {
                            td.className = 'surface-row';
                            td.textContent = cell || '';
                        } else if (rowIndex === 1 || rowIndex === 10) {
                            td.className = 'surface-row';
                            td.textContent = cell || '';
                        } else if (rowIndex === 9) {
                            td.className = 'tooth-number-row';
                            td.textContent = cell || '';
                        } else if (this.isDataRow(rowIndex) && colIndex > 0) {
                            td.className = 'data-cell';
                            td.innerHTML = '&nbsp;';
                            
                            const toothNumber = this.getToothNumberForCell(tableType, rowIndex, colIndex, data);
                            const measurementType = this.getMeasurementType(rowIndex, tableType);
                            const surface = this.getSurfaceForCell(rowIndex, colIndex, data);
                            const surfaceIndex = this.getSurfaceIndex(surface);
                            
                            if (toothNumber && measurementType && surface) {
                                td.setAttribute('data-tooth', toothNumber);
                                td.setAttribute('data-measurement', measurementType);
                                td.setAttribute('data-surface', surface);
                                td.setAttribute('data-surface-type', this.getSurfaceType(rowIndex));
                                
                                const surfaceType = this.getSurfaceType(rowIndex);
                                td.id = `${measurementType}-${toothNumber}-${surfaceType}-${surfaceIndex}`;
                            }
                        } else {
                            td.textContent = cell || '';
                            if (!cell && cell !== 0) {
                                td.innerHTML = '&nbsp;';
                            }
                        }
                        
                        tr.appendChild(td);
                    });
                    
                    table.appendChild(tr);
                });
            }

            isDataRow(rowIndex) {
                const dataRows = [2, 3, 4, 5, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17];
                return dataRows.includes(rowIndex);
            }

            getSurfaceType(rowIndex) {
                if (rowIndex >= 2 && rowIndex <= 8) {
                    return 'buccal';
                } else if (rowIndex >= 11 && rowIndex <= 17) {
                    return 'lingual';
                }
                return 'buccal';
            }

            getToothNumberForCell(tableType, rowIndex, colIndex, data) {
                const toothRowIndex = 9;
                if (rowIndex === toothRowIndex) return null;
                
                const toothRow = data[toothRowIndex];
                
                for (let i = colIndex; i >= 1; i--) {
                    if (toothRow[i] && !isNaN(toothRow[i])) {
                        const toothNum = parseInt(toothRow[i]);
                        if (toothNum >= 1 && toothNum <= 32) {
                            return toothNum;
                        }
                    }
                }
                
                return null;
            }

            getMeasurementType(rowIndex, tableType) {
                const measurementMap = {
                    2: 'PD', 3: 'GM', 4: 'CAL', 5: 'Furc', 6: 'Sup', 7: 'BOP', 8: 'Mob',
                    11: 'PD', 12: 'GM', 13: 'CAL', 14: 'Furc', 15: 'Sup', 16: 'BOP', 17: 'Mob'
                };
                return measurementMap[rowIndex];
            }

            getSurfaceForCell(rowIndex, colIndex, data) {
                let surfaceRowIndex;
                if (rowIndex >= 2 && rowIndex <= 8) {
                    surfaceRowIndex = 1;
                } else if (rowIndex >= 11 && rowIndex <= 17) {
                    surfaceRowIndex = 10;
                } else {
                    return null;
                }
                
                const surfaceRow = data[surfaceRowIndex];
                
                for (let i = colIndex; i >= 1; i--) {
                    if (surfaceRow[i] && ['D', 'B', 'M', 'L', 'F'].includes(surfaceRow[i])) {
                        return surfaceRow[i];
                    }
                }
                
                return null;
            }

            getSurfaceIndex(surface) {
                const surfaceMap = { 'D': 0, 'B': 1, 'M': 2, 'L': 1, 'F': 1 };
                return surfaceMap[surface] || 0;
            }

            setupEventListeners() {
                const voiceButton = document.getElementById('voiceButton');
                const clearButton = document.getElementById('clearButton');

                voiceButton.addEventListener('click', () => {
                    if (this.isRecording) {
                        this.stopRecording();
                    } else {
                        this.startRecording();
                    }
                });

                clearButton.addEventListener('click', () => {
                    this.clearAllData();
                });
            }

            async connectToServer() {
                try {
                    this.updateConnectionStatus('Connecting...', false);
                    
                    this.websocket = new WebSocket(this.serverUri);
                    
                    this.websocket.onopen = () => {
                        this.isConnected = true;
                        this.updateConnectionStatus('Connected', true);
                        this.showFeedback('Connected to voice recognition server', 'success');
                    };

                    this.websocket.onmessage = (event) => {
                        this.handleServerMessage(event.data);
                    };

                    this.websocket.onclose = () => {
                        this.isConnected = false;
                        this.updateConnectionStatus('Disconnected', false);
                        this.showFeedback('Connection lost. Attempting to reconnect...', 'error');
                        
                        setTimeout(() => {
                            if (!this.isConnected) {
                                this.connectToServer();
                            }
                        }, 3000);
                    };

                    this.websocket.onerror = (error) => {
                        this.showFeedback('Connection error', 'error');
                    };

                } catch (error) {
                    this.showFeedback('Failed to connect to server', 'error');
                }
            }

			markSingleToothAsMissing(toothNumber) {
				console.log(`❌ Marking single tooth ${toothNumber} as missing`);
				
				// Валидация
				if (!toothNumber || !Number.isInteger(toothNumber) || toothNumber < 1 || toothNumber > 32) {
					console.error(`❌ Invalid tooth number: ${toothNumber}`);
					this.showFeedback(`❌ Invalid tooth number: ${toothNumber}`, 'error');
					return;
				}
				
				// Помечаем зуб как отсутствующий в данных
				if (this.teethData[toothNumber]) {
					this.teethData[toothNumber].missing = true;
					console.log(`📝 Updated teethData for tooth ${toothNumber}`);
				}
				
				// Находим все ячейки для этого зуба
				const toothCells = document.querySelectorAll(`[id*="-${toothNumber}-"]`);
				console.log(`🔍 Found ${toothCells.length} cells for tooth ${toothNumber}`);
				
				if (toothCells.length === 0) {
					console.warn(`⚠️ No cells found for tooth ${toothNumber}`);
					this.showFeedback(`⚠️ Could not find cells for tooth ${toothNumber}`, 'error');
					return;
				}
				
				// Помечаем все ячейки как отсутствующие
				let markedCells = 0;
				toothCells.forEach(cell => {
					cell.textContent = 'X';
					cell.innerHTML = 'X'; // На случай если textContent не работает
					
					// Убираем старые классы
					cell.classList.remove('updated', 'bleeding', 'high-probing', 'critical-probing', 'high-cal', 'critical-cal');
					
					// Добавляем класс missing-tooth
					cell.classList.add('missing-tooth');
					
					console.log(`✅ Marked cell ${cell.id} as missing`);
					markedCells++;
				});
				
				// Обновляем статистику
				this.stats.missingCount++;
				this.stats.teethUpdated++;
				
				console.log(`✅ Successfully marked tooth ${toothNumber} as missing (${markedCells} cells updated)`);
				this.showFeedback(`✅ Tooth ${toothNumber} marked as missing`, 'success');
			}

            handleServerMessage(data) {
                try {
                    const message = JSON.parse(data);
                    console.log('📨 Received message:', message);
                    
                    this.lastMessageTime = new Date().toISOString();
                    
                    switch (message.type) {
                        case 'transcription':
                            this.handleTranscription(message);
                            break;
                        case 'periodontal_update':
                            this.handlePeriodontalUpdate(message);
                            break;
                        case 'cody_command':
                            this.handleCodyCommand(message);
                            break;
                        case 'stats':
                            this.handleServerStats(message);
                            break;
                        case 'model_info':
                            this.handleModelInfo(message);
                            break;
                        case 'pong':
                            console.log('🏓 Pong received');
                            this.showFeedback('Connection test successful', 'success');
                            break;
							
						case 'partial_command_feedback':
							this.handlePartialCommand(message);
							break;
						case 'instant_execution':
							this.handleInstantExecution(message);
							break;	
                        case 'connection':
                            console.log('🔗 Connection info:', message);
                            this.showFeedback(`Connected to server with features: ${Object.keys(message.features || {}).join(', ')}`, 'success');
                            break;
                        default:
                            console.warn('⚠️ Unknown message type:', message.type);
                    }
                } catch (error) {
                    console.error('❌ Error parsing server message:', error);
                    console.error('📄 Raw message:', data);
                }
            }
			handlePartialCommand(message) {
				if (message.partial_text) {
					this.stats.partialCommands++; // ДОБАВИТЬ эту строку
				}
				this.showFeedback(`⏳ Waiting for completion: "${message.partial_text}"`, 'partial-command-indicator');
				this.showInstantIndicator(false); // Показать ожидание
			}

			handleInstantExecution(message) {
				this.showInstantIndicator(true); // Показать мгновенное выполнение
				this.showFeedback(`⚡ INSTANT: ${message.message}`, 'success');
			}

			showInstantIndicator(isInstant) {
				const indicator = document.getElementById('instantIndicator');
				if (isInstant) {
					indicator.textContent = '⚡ INSTANT EXECUTED';
					indicator.classList.add('active');
					setTimeout(() => {
						indicator.classList.remove('active');
					}, 2000);
				} else {
					indicator.textContent = '⏳ WAITING...';
					indicator.classList.add('active');
					indicator.style.background = 'linear-gradient(135deg, #f39c12, #e67e22)';
				}
			}
			
		handlePeriodontalUpdate(message) {
			console.log('🦷 Handling periodontal update:', message);
			
			if (message.instant_execution) {
				this.showInstantIndicator(true);
				this.stats.instantCommands++;
				this.showFeedback(`⚡ INSTANT: ${message.message}`, 'success');
			}

			if (message.success) {
				const tooth = message.tooth_number;
				const measurementType = message.measurement_type;
				const surface = message.surface;
				const position = message.position;
				const values = message.values || [];
				const measurements = message.measurements || {};
				
				console.log(`📊 Processing: ${measurementType} for tooth ${tooth}`);
				console.log(`🔧 Surface: ${surface}, Position: ${position}`);
				console.log(`📈 Values:`, values);
				console.log(`📋 Measurements:`, measurements);
				
				// ✅ ПРОСТАЯ ОБРАБОТКА MISSING TEETH
				if (measurementType === 'missing_teeth') {
					console.log('🦷 MISSING TEETH DETECTED - Simple handling');
					// ОДИН зуб - ПРОСТАЯ обработка
					this.markSingleToothAsMissing(tooth);
				} else {
					// Обычная обработка для других типов измерений
					this.updateCellsByMeasurementType(tooth, measurementType, surface, position, values, measurements);
					this.stats.teethUpdated++;
				}
				
				this.updateStats();
				this.showFeedback(`✅ ${message.message}`, 'success');
			} else {
				this.showFeedback(`❌ ${message.message || 'Periodontal update failed'}`, 'error');
			}
		}

			updateCellsByMeasurementType(tooth, measurementType, surface, position, values, measurements) {
				console.log(`🔧 Updating cells for tooth ${tooth}, type: ${measurementType}`);
				
				switch (measurementType) {
					case 'probing_depth':
						this.updateProbingDepthCells(tooth, surface, values);
						break;
					case 'bleeding':
					case 'bleeding_on_probing':
						this.updateBleedingCells(tooth, surface, position, values);
						break;
					case 'suppuration':
						this.updateSuppurationCells(tooth, surface, position, values);
						break;
					case 'mobility':
						this.updateMobilityCells(tooth, values);
						break;
					case 'furcation':
						this.updateFurcationCells(tooth, values);
						break;
					case 'gingival_margin':
						this.updateGingivalMarginCells(tooth, surface, values);
						break;
					case 'missing_teeth':
						// ⭐ ЕДИНСТВЕННАЯ правильная обработка missing_teeth
						this.handleMissingTeethUpdate(measurements);
						break;
						
					case 'gingival_margin':
						this.updateGingivalMarginCells(tooth, surface, values);
						break;	
					default:
						console.warn(`⚠️ Unknown measurement type: ${measurementType}`);
						this.updateCellsFromServer(tooth, measurements);
				}
			}
			
		handleMissingTeethUpdate(message, measurements) {
			console.log('🦷 ENHANCED Missing teeth handler:', message);
			console.log('📊 Measurements object:', measurements);
			
			// Извлекаем номера зубов из ВСЕХ возможных источников
			let toothNumbers = [];
			
			// 1. Проверяем tooth_number в сообщении
			if (message.tooth_number && Number.isInteger(message.tooth_number) && message.tooth_number >= 1 && message.tooth_number <= 32) {
				toothNumbers.push(message.tooth_number);
				console.log(`✅ Found tooth from message.tooth_number: ${message.tooth_number}`);
			}
			
			// 2. Проверяем values в сообщении
			if (message.values && Array.isArray(message.values)) {
				const validValues = message.values.filter(v => Number.isInteger(v) && v >= 1 && v <= 32);
				toothNumbers = toothNumbers.concat(validValues);
				console.log(`✅ Found teeth from message.values: ${validValues}`);
			}
			
			// 3. Проверяем measurements объект
			if (measurements) {
				// Проверяем missing_teeth
				if (measurements.missing_teeth && Array.isArray(measurements.missing_teeth)) {
					const validTeeth = measurements.missing_teeth.filter(v => Number.isInteger(v) && v >= 1 && v <= 32);
					toothNumbers = toothNumbers.concat(validTeeth);
					console.log(`✅ Found teeth from measurements.missing_teeth: ${validTeeth}`);
				}
				
				// Проверяем teeth
				if (measurements.teeth && Array.isArray(measurements.teeth)) {
					const validTeeth = measurements.teeth.filter(v => Number.isInteger(v) && v >= 1 && v <= 32);
					toothNumbers = toothNumbers.concat(validTeeth);
					console.log(`✅ Found teeth from measurements.teeth: ${validTeeth}`);
				}
				
				// Проверяем values
				if (measurements.values && Array.isArray(measurements.values)) {
					const validTeeth = measurements.values.filter(v => Number.isInteger(v) && v >= 1 && v <= 32);
					toothNumbers = toothNumbers.concat(validTeeth);
					console.log(`✅ Found teeth from measurements.values: ${validTeeth}`);
				}
			}
			
			// 4. ДОПОЛНИТЕЛЬНАЯ ПРОВЕРКА: парсим оригинальный текст как fallback
			if (toothNumbers.length === 0 && message.original_text) {
				const text = message.original_text.toLowerCase();
				console.log(`🔍 Parsing original text for numbers: "${text}"`);
				
				// Словарь для числовых слов
				const wordToNum = {
					'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
					'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10,
					'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14,
					'fifteen': 15, 'sixteen': 16, 'seventeen': 17, 'eighteen': 18,
					'nineteen': 19, 'twenty': 20, 'thirty': 30, 'thirty-one': 31, 'thirty-two': 32
				};
				
				// Ищем числа в тексте
				const words = text.split(/\s+/);
				for (const word of words) {
					const cleanWord = word.replace(/[^\w]/g, '');
					
					// Проверяем цифры
					if (/^\d+$/.test(cleanWord)) {
						const num = parseInt(cleanWord);
						if (num >= 1 && num <= 32) {
							toothNumbers.push(num);
							console.log(`✅ Found tooth number from text: ${num}`);
						}
					}
					// Проверяем числовые слова
					else if (wordToNum[cleanWord]) {
						const num = wordToNum[cleanWord];
						if (num >= 1 && num <= 32) {
							toothNumbers.push(num);
							console.log(`✅ Found tooth from word "${cleanWord}": ${num}`);
						}
					}
				}
				
				// Специальная обработка для "too" = "two" = зуб 2
				if ((text.includes('too') || text.includes('two')) && text.includes('missing')) {
					if (!toothNumbers.includes(2)) {
						toothNumbers.push(2);
						console.log(`✅ Found tooth 2 from 'too'/'two' in missing context`);
					}
				}
			}
			
			// Убираем дубликаты и сортируем
			toothNumbers = [...new Set(toothNumbers)].sort((a, b) => a - b);
			
			console.log(`🎯 FINAL tooth numbers to mark as missing: ${toothNumbers}`);
			
			if (toothNumbers.length > 0) {
				// Отмечаем каждый зуб как отсутствующий
				toothNumbers.forEach(tooth => {
					this.markToothAsMissing(tooth);
					console.log(`✅ Successfully marked tooth ${tooth} as missing`);
				});
				
				// Обновляем статистику
				this.stats.missingCount += toothNumbers.length;
				this.stats.teethUpdated += toothNumbers.length;
				
				// Показываем сообщение об успехе
				const message_text = `✅ Marked ${toothNumbers.length} teeth as missing: ${toothNumbers.join(', ')}`;
				this.showFeedback(message_text, 'success');
				
				// Обновляем статистику на экране
				this.updateStats();
				
				console.log(`🎉 SUCCESS: Missing teeth operation completed for teeth: ${toothNumbers.join(', ')}`);
				
			} else {
				console.error('❌ No valid tooth numbers found for missing teeth command');
				this.showFeedback('❌ Could not identify tooth numbers from missing teeth command', 'error');
			}
		}
            
            updateProbingDepthCells(tooth, surface, values) {
				if (!values || values.length !== 3) return;
				
				const surfaceType = surface || 'buccal';
				console.log(`📏 Updating probing depth for tooth ${tooth} ${surfaceType}:`, values);
				
				values.forEach((depth, index) => {
					const element = document.getElementById(`PD-${tooth}-${surfaceType}-${index}`);
					if (element) {
						this.updateCell(element, depth);
						console.log(`✅ Updated PD-${tooth}-${surfaceType}-${index} = ${depth}`);
						
						// Apply styling based on depth
						element.classList.remove('high-probing', 'critical-probing');
						if (depth >= 5) {
							element.classList.add('critical-probing');
						} else if (depth >= 4) {
							element.classList.add('high-probing');
						}
					} else {
						console.warn(`⚠️ Element not found: PD-${tooth}-${surfaceType}-${index}`);
					}
				});
			}
					
            updateBleedingCells(tooth, surface, position, values) {
                const surfaceType = surface || 'buccal';
                const positionIndex = this.getPositionIndex(position || 'distal');
                const isPositive = values && values.length > 0 ? values[0] : true;
                
                console.log(`🩸 Updating bleeding for tooth ${tooth} ${surfaceType} ${position}:`, isPositive);
                
                const element = document.getElementById(`BOP-${tooth}-${surfaceType}-${positionIndex}`);
                if (element) {
                    this.updateCell(element, isPositive ? '🩸' : '');
                    if (isPositive) {
                        element.classList.add('bleeding');
                    }
                    console.log(`✅ Updated BOP-${tooth}-${surfaceType}-${positionIndex} = ${isPositive ? '🩸' : 'negative'}`);
                } else {
                    console.warn(`⚠️ Element not found: BOP-${tooth}-${surfaceType}-${positionIndex}`);
                }
            }
            
            updateSuppurationCells(tooth, surface, position, values) {
                const surfaceType = surface || 'buccal';
                const positionIndex = this.getPositionIndex(position || 'distal');
                const isPresent = values && values.length > 0 ? values[0] : true;
                
                console.log(`💧 Updating suppuration for tooth ${tooth} ${surfaceType} ${position}:`, isPresent);
                
                const element = document.getElementById(`Sup-${tooth}-${surfaceType}-${positionIndex}`);
                if (element) {
                    this.updateCell(element, isPresent ? '💧' : '');
                    console.log(`✅ Updated Sup-${tooth}-${surfaceType}-${positionIndex} = ${isPresent ? '💧' : 'absent'}`);
                } else {
                    console.warn(`⚠️ Element not found: Sup-${tooth}-${surfaceType}-${positionIndex}`);
                }
            }
            
            updateMobilityCells(tooth, values) {
                const grade = values && values.length > 0 ? values[0] : 0;
                
                console.log(`🔄 Updating mobility for tooth ${tooth}:`, grade);
                
                ['buccal', 'lingual'].forEach(surface => {
                    const element = document.getElementById(`Mob-${tooth}-${surface}-0`);
                    if (element) {
                        this.updateCell(element, grade);
                        console.log(`✅ Updated Mob-${tooth}-${surface}-0 = ${grade}`);
                    }
                });
            }
            
            updateFurcationCells(tooth, values) {
                const furcationClass = values && values.length > 0 ? values[0] : 0;
                
                console.log(`🔱 Updating furcation for tooth ${tooth}:`, furcationClass);
                
                ['buccal', 'lingual'].forEach(surface => {
                    const element = document.getElementById(`Furc-${tooth}-${surface}-0`);
                    if (element) {
                        this.updateCell(element, furcationClass);
                        console.log(`✅ Updated Furc-${tooth}-${surface}-0 = ${furcationClass}`);
                    }
                });
            }
            
		updateGingivalMarginCells(tooth, surface, values) {
			if (!values || values.length !== 3) {
				console.warn(`⚠️ Invalid GM values for tooth ${tooth}:`, values);
				return;
			}
			
			// ✅ ИСПРАВЛЕНИЕ: Если surface не указана, обновляем обе поверхности
			const surfacesToUpdate = surface ? [surface] : ['buccal', 'lingual'];
			
			surfacesToUpdate.forEach(surfaceType => {
				console.log(`📐 Updating gingival margin for tooth ${tooth} ${surfaceType}:`, values);
				
				values.forEach((margin, index) => {
					const element = document.getElementById(`GM-${tooth}-${surfaceType}-${index}`);
					if (element) {
						this.updateCell(element, margin);
						console.log(`✅ Updated GM-${tooth}-${surfaceType}-${index} = ${margin}`);
						
						// ✅ НОВОЕ: Автоматический расчет CAL после обновления GM
						this.calculateCAL(element);
					} else {
						console.warn(`⚠️ Element not found: GM-${tooth}-${surfaceType}-${index}`);
					}
				});
			});
		}
            
			markToothAsMissing(tooth) {
				console.log(`❌ Marking tooth ${tooth} as missing`);
				
				// Помечаем зуб как отсутствующий в данных
				if (this.teethData[tooth]) {
					this.teethData[tooth].missing = true;
				}
				// Находим все ячейки для этого зуба и помечаем как отсутствующие
				const toothCells = document.querySelectorAll(`[id*="-${tooth}-"]`);
				console.log(`🔍 Found ${toothCells.length} cells for tooth ${tooth}`);
				
				toothCells.forEach(cell => {
					cell.textContent = 'X';
					cell.classList.remove('updated', 'bleeding', 'high-probing', 'critical-probing', 'high-cal', 'critical-cal');
					cell.classList.add('missing-tooth');
					console.log(`✅ Marked cell ${cell.id} as missing`);
				});
				
				// Обновляем статистику
				this.updateStats();
				
				console.log(`✅ Successfully marked tooth ${tooth} as missing`);
			}

            updateCellsFromServer(tooth, measurements) {
                if (measurements.probing_depth && Array.isArray(measurements.probing_depth)) {
                    measurements.probing_depth.forEach((depth, index) => {
                        let element = document.getElementById(`PD-${tooth}-buccal-${index}`);
                        if (element) {
                            this.updateCell(element, depth);
                        }
                    });
                }
            }

            handleTranscription(message) {
                if (message.text && message.text !== 'NO_SPEECH') {
                    this.showFeedback(`Heard: "${message.text}"`, 'processing');
                    this.processVoiceCommand(message.text);
                }
            }

            handleCodyCommand(message) {
                if (message.success) {
                    this.showFeedback(`✅ ${message.message}`, 'success');
                } else {
                    this.showFeedback(`❌ ${message.message}`, 'error');
                }
            }

            handleServerStats(message) {
                console.log('Server stats:', message);
            }

            handleModelInfo(message) {
                console.log('Model info:', message);
            }

            processVoiceCommand(text) {
                const command = this.parsePeriodontalCommand(text.toLowerCase());
                
                if (command) {
                    this.executeCommand(command);
                    this.stats.commandsCount++;
                    this.updateStats();
                } else {
                    this.showFeedback('Command not recognized. Try the new command format.', 'error');
                }
            }
			recalculateAllCAL() {
				for (let tooth = 1; tooth <= 32; tooth++) {
					['buccal', 'lingual'].forEach(surfaceType => {
						[0, 1, 2].forEach(surfaceIndex => {
							const pdElement = document.getElementById(`PD-${tooth}-${surfaceType}-${surfaceIndex}`);
							if (pdElement && pdElement.textContent.trim() && !isNaN(pdElement.textContent.trim())) {
								this.calculateCAL(pdElement);
							}
						});
					});
				}
			}
            parsePeriodontalCommand(text) {
                // 1. Probing depth commands
                let match = text.match(/probing depth on tooth number (\d+) (buccal|lingual) surface (\d+) (\d+) (\d+)/i);
                if (match) {
                    const tooth = parseInt(match[1]);
                    const surface = match[2].toLowerCase();
                    const depths = [parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
                    
                    if (tooth >= 1 && tooth <= 32 && depths.every(d => d >= 1 && d <= 12)) {
                        return {
                            type: 'probing_depth',
                            tooth: tooth,
                            surface: surface,
                            values: depths
                        };
                    }
                }

                // 2. Bleeding on probing commands
                match = text.match(/bleeding on probing tooth (\d+) (buccal|lingual) (distal|mesial|mid|middle)/i);
                if (match) {
                    const tooth = parseInt(match[1]);
                    const surface = match[2].toLowerCase();
                    const position = match[3].toLowerCase();
                    
                    if (tooth >= 1 && tooth <= 32) {
                        return {
                            type: 'bleeding',
                            tooth: tooth,
                            surface: surface,
                            position: position === 'mid' || position === 'middle' ? 'mid' : position,
                            value: true
                        };
                    }
                }

                // 3. Suppuration commands
                match = text.match(/suppuration present on tooth (\d+) (buccal|lingual) (distal|mesial|mid|middle)/i);
                if (match) {
                    const tooth = parseInt(match[1]);
                    const surface = match[2].toLowerCase();
                    const position = match[3].toLowerCase();
                    
                    if (tooth >= 1 && tooth <= 32) {
                        return {
                            type: 'suppuration',
                            tooth: tooth,
                            surface: surface,
                            position: position === 'mid' || position === 'middle' ? 'mid' : position,
                            value: true
                        };
                    }
                }

                // 4. Mobility commands
                match = text.match(/tooth (\d+) has mobility grade (\d+)/i);
                if (match) {
                    const tooth = parseInt(match[1]);
                    const grade = parseInt(match[2]);
                    
                    if (tooth >= 1 && tooth <= 32 && grade >= 0 && grade <= 3) {
                        return {
                            type: 'mobility',
                            tooth: tooth,
                            value: grade
                        };
                    }
                }

                // 5. Furcation commands
                match = text.match(/furcation class (\d+) on tooth (\d+)/i);
                if (match) {
                    const grade = parseInt(match[1]);
                    const tooth = parseInt(match[2]);
                    
                    if (tooth >= 1 && tooth <= 32 && grade >= 1 && grade <= 3) {
                        return {
                            type: 'furcation',
                            tooth: tooth,
                            value: grade
                        };
                    }
                }

                // 6. Gingival margin commands
                match = text.match(/gingival margin on tooth (\d+) ((?:minus \d+|plus \d+|\d+)(?: (?:minus \d+|plus \d+|\d+)){2})/i);
                if (match) {
                    const tooth = parseInt(match[1]);
                    const valuesText = match[2];
                    
                    const values = this.parseGingivalMarginValues(valuesText);
                    
                    if (tooth >= 1 && tooth <= 32 && values && values.length === 3) {
                        return {
                            type: 'gingival_margin',
                            tooth: tooth,
                            values: values
                        };
                    }
                }

                // 7. Missing teeth commands
                match = text.match(/missing teeth ([\d\s]+)/i);
                if (match) {
                    const teethNumbers = match[1].split(/\s+/).map(n => parseInt(n.trim())).filter(n => n >= 1 && n <= 32);
                    
                    if (teethNumbers.length > 0) {
                        return {
                            type: 'missing_teeth',
                            teeth: teethNumbers
                        };
                    }
                }

                return null;
            }

            parseGingivalMarginValues(text) {
                const values = [];
                const parts = text.trim().split(/\s+/);
                
                for (let i = 0; i < parts.length; i++) {
                    if (parts[i] === 'minus' && i + 1 < parts.length) {
                        values.push(-parseInt(parts[i + 1]));
                        i++;
                    } else if (parts[i] === 'plus' && i + 1 < parts.length) {
                        values.push(parseInt(parts[i + 1]));
                        i++;
                    } else if (!isNaN(parts[i])) {
                        values.push(parseInt(parts[i]));
                    }
                }
                
                return values.length === 3 ? values : null;
            }

            executeCommand(command) {
                switch (command.type) {
                    case 'probing_depth':
                        this.updateProbingDepthCells(command.tooth, command.surface, command.values);
                        break;
                    case 'bleeding':
                        this.updateBleedingCells(command.tooth, command.surface, command.position, [command.value]);
                        break;
                    case 'suppuration':
                        this.updateSuppurationCells(command.tooth, command.surface, command.position, [command.value]);
                        break;
                    case 'mobility':
                        this.updateMobilityCells(command.tooth, [command.value]);
                        break;
                    case 'furcation':
                        this.updateFurcationCells(command.tooth, [command.value]);
                        break;
                    case 'gingival_margin':
                        this.updateGingivalMarginCells(command.tooth, 'buccal', command.values);
                        this.updateGingivalMarginCells(command.tooth, 'lingual', command.values);
                        break;
                    case 'missing_teeth':
                        command.teeth.forEach(tooth => this.markToothAsMissing(tooth));
                        break;
                }
                
                this.stats.teethUpdated++;
                this.updateStats();
                this.showFeedback(`Command executed successfully`, 'success');
            }

            getPositionIndex(position) {
                const positionMap = { 
                    'distal': 0, 
                    'mid': 1, 
                    'middle': 1, 
                    'mesial': 2 
                };
                return positionMap[position?.toLowerCase()] || 0;
            }

			updateCell(element, value) {
				element.textContent = value;
				element.classList.add('updated');
				
				// Auto-calculate CAL when PD or GM is updated
				if (element.id.includes('PD-') || element.id.includes('GM-')) {
					this.calculateCAL(element);
				}
				
				setTimeout(() => {
					element.classList.remove('updated');
				}, 3000);
			}
			
			calculateCAL(changedElement) {
				// Extract tooth number, surface type, and surface index from element ID
				const idParts = changedElement.id.split('-');
				if (idParts.length < 4) return;
				
				const measurementType = idParts[0]; // PD or GM
				const tooth = idParts[1];
				const surfaceType = idParts[2]; // buccal or lingual
				const surfaceIndex = idParts[3]; // 0, 1, or 2
				
				// Get corresponding PD and GM elements
				const pdElement = document.getElementById(`PD-${tooth}-${surfaceType}-${surfaceIndex}`);
				const gmElement = document.getElementById(`GM-${tooth}-${surfaceType}-${surfaceIndex}`);
				const calElement = document.getElementById(`CAL-${tooth}-${surfaceType}-${surfaceIndex}`);
				
				if (!pdElement || !gmElement || !calElement) return;
				
				// Get values from PD and GM cells
				const pdValue = pdElement.textContent.trim();
				const gmValue = gmElement.textContent.trim();
				
				// Only calculate if both PD and GM have numeric values
				if (pdValue && gmValue && !isNaN(pdValue) && !isNaN(gmValue)) {
					const pd = parseFloat(pdValue);
					const gm = parseFloat(gmValue);
					const cal = pd + gm;
					
					// Update CAL cell
					calElement.textContent = cal.toString();
					calElement.classList.add('updated');
					
					// Apply styling based on CAL value
					calElement.classList.remove('high-cal', 'critical-cal');
					if (cal >= 7) {
						calElement.classList.add('critical-cal');
					} else if (cal >= 5) {
						calElement.classList.add('high-cal');
					}
					
					setTimeout(() => {
						calElement.classList.remove('updated');
					}, 3000);
					
					console.log(`📊 CAL calculated for tooth ${tooth} ${surfaceType}-${surfaceIndex}: PD(${pd}) + GM(${gm}) = CAL(${cal})`);
				} else if (!pdValue || !gmValue || pdValue === '&nbsp;' || gmValue === '&nbsp;') {
					// Clear CAL if either PD or GM is empty
					calElement.textContent = '';
					calElement.innerHTML = '&nbsp;';
					calElement.classList.remove('high-cal', 'critical-cal');
				}
			}

            startRecording() {
                if (!this.isConnected) {
                    this.showFeedback('Please wait for connection to server', 'error');
                    return;
                }

                this.isRecording = true;
                const button = document.getElementById('voiceButton');
                button.textContent = '🛑 Stop Recording';
                button.classList.add('recording');
                
                this.showFeedback('🎤 Listening... Speak your command', 'processing');
            }

            stopRecording() {
                this.isRecording = false;
                const button = document.getElementById('voiceButton');
                button.textContent = '🎤 Start Voice Input';
                button.classList.remove('recording');
                
                this.showFeedback('Recording stopped', 'success');
            }

            clearAllData() {
                if (confirm('Are you sure you want to clear all periodontal data?')) {
                    this.initializeTeethData();
                    
                    document.querySelectorAll('.data-cell').forEach(cell => {
                        cell.textContent = '';
                        cell.innerHTML = '&nbsp;';
                        cell.className = 'data-cell';
                    });
                    
                    this.stats = {
                        commandsCount: 0,
                        teethUpdated: 0,
                        bleedingCount: 0,
                        missingCount: 0
                    };
                    this.updateStats();
                    
                    this.showFeedback('All data cleared', 'success');
                }
            }
			

            debugConnection() {
                console.log('🔍 === CONNECTION DEBUG INFO ===');
                console.log(`🌐 WebSocket State: ${this.websocket ? this.websocket.readyState : 'null'}`);
                console.log(`🔗 Is Connected: ${this.isConnected}`);
                console.log(`📡 Server URI: ${this.serverUri}`);
                console.log(`⏱️ Last message time: ${this.lastMessageTime || 'never'}`);
                
                // Test connection
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    console.log('📤 Sending ping test...');
                    this.websocket.send(JSON.stringify({
                        type: 'ping',
                        timestamp: new Date().toISOString(),
                        debug: true
                    }));
                } else {
                    console.log('❌ WebSocket not ready, attempting reconnection...');
                    this.connectToServer();
                }
                
                // Show debug info to user
                this.showFeedback(`🔍 Debug info logged to console. Check browser console (F12) for details.`, 'processing');
            }

            updateStats() {
                document.getElementById('commandsCount').textContent = this.stats.commandsCount;
                document.getElementById('teethUpdated').textContent = this.stats.teethUpdated;
                let missingCount = 0;
				Object.values(this.teethData).forEach(tooth => {
					if (tooth.missing) {
						missingCount++;
					}
				});
				this.stats.missingCount = missingCount;
				document.getElementById('missingCount').textContent = missingCount;
                
                let bleedingCount = 0;
                Object.values(this.teethData).forEach(tooth => {
                    bleedingCount += tooth.bleedingBuccal.filter(b => b).length;
                    bleedingCount += tooth.bleedingLingual.filter(b => b).length;
                });
                this.stats.bleedingCount = bleedingCount;
                document.getElementById('bleedingCount').textContent = bleedingCount;
                
                let totalDepth = 0;
                let measurementCount = 0;
                Object.values(this.teethData).forEach(tooth => {
                    tooth.probingDepthBuccal.forEach(depth => {
                        if (depth && !isNaN(depth)) {
                            totalDepth += parseInt(depth);
                            measurementCount++;
                        }
                    });
                    tooth.probingDepthLingual.forEach(depth => {
                        if (depth && !isNaN(depth)) {
                            totalDepth += parseInt(depth);
                            measurementCount++;
                        }
                    });
                });
                
                const avgProbing = measurementCount > 0 ? (totalDepth / measurementCount).toFixed(1) + 'mm' : '-';
                document.getElementById('avgProbing').textContent = avgProbing;
				document.getElementById('instantCommands').textContent = this.stats.instantCommands || 0;
				document.getElementById('partialCommands').textContent = this.stats.partialCommands || 0;
            }

            updateConnectionStatus(text, connected) {
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                
                statusText.textContent = text;
                indicator.className = 'status-indicator' + (connected ? ' connected' : '');
            }

            showFeedback(message, type = 'info') {
                const feedbackContainer = document.getElementById('voiceFeedback');
                const feedbackItem = document.createElement('div');
                feedbackItem.className = `feedback-item ${type}`;
                
                feedbackItem.innerHTML = `
                    <div class="feedback-text">${message}</div>
                    <div class="feedback-details">${new Date().toLocaleTimeString()}</div>
                `;
                
                feedbackContainer.appendChild(feedbackItem);
                
                setTimeout(() => {
                    feedbackItem.style.animation = 'slideOut 0.5s ease forwards';
                    setTimeout(() => {
                        if (feedbackItem.parentNode) {
                            feedbackItem.parentNode.removeChild(feedbackItem);
                        }
                    }, 500);
                }, 5000);
                
                while (feedbackContainer.children.length > 5) {
                    feedbackContainer.removeChild(feedbackContainer.firstChild);
                }
            }
        }


		

		function testCALCalculation() {
			if (window.clinicalChart) {
				window.clinicalChart.showFeedback('Testing CAL auto-calculation...', 'processing');
				
				// Test PD values for tooth 14
				window.clinicalChart.processVoiceCommand('probing depth on tooth number 14 buccal surface 3 2 4');
				
				// Wait a bit then add GM values
				setTimeout(() => {
					window.clinicalChart.processVoiceCommand('gingival margin on tooth 14 minus 1 0 plus 1');
					window.clinicalChart.showFeedback('CAL should now be calculated automatically: PD + GM = CAL', 'success');
				}, 500);
			}
		}

        function testCommand(command) {
            if (window.clinicalChart) {
                window.clinicalChart.showFeedback(`Testing: "${command}"`, 'processing');
                window.clinicalChart.processVoiceCommand(command);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.clinicalChart = new ClinicalPeriodontalChart();
        });
    </script>
</body>
</html>